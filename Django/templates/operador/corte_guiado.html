{% extends 'layout/layout.html' %}
{% load static %}

{% block content %}
<div class="container-fluid">
  <div class="row mb-3">
    <div class="col-12">
      <div class="d-flex justify-content-between align-items-center">
        <div>
          <h4 class="mb-0">{{ proyecto.nombre }}</h4>
          <small class="text-muted">Proyecto: {{ proyecto.public_id|default:proyecto.id }} | Cliente: {{ proyecto.cliente.nombre }}</small>
        </div>
        <a href="{% url 'operador_home' %}" class="btn btn-outline-secondary">
          <i class="ri-arrow-left-line"></i> Volver a proyectos
        </a>
      </div>
    </div>
  </div>

  <!-- Panel de control superior -->
  <div class="row mb-3">
    <div class="col-12">
      <div class="card">
        <div class="card-body">
          <div class="row align-items-center">
            <div class="col-md-3">
              <label class="form-label fw-semibold">Seleccionar Tablero</label>
              <select id="tableroSelect" class="form-select">
                <option value="">-- Selecciona un tablero --</option>
              </select>
            </div>
            <div class="col-md-3">
              <div class="text-center">
                <div class="fw-semibold text-muted small">Corte Actual</div>
                <div class="fs-4 fw-bold" id="corteActual">-</div>
                <div class="small text-muted">de <span id="totalCortes">-</span> cortes</div>
              </div>
            </div>
            <div class="col-md-3">
              <div class="text-center">
                <div class="fw-semibold text-muted small">Progreso</div>
                <div class="progress mt-2" style="height: 25px;">
                  <div id="progressBar" class="progress-bar bg-success" role="progressbar" style="width: 0%">0%</div>
                </div>
              </div>
            </div>
            <div class="col-md-3 text-end">
              <button id="btnReiniciar" class="btn btn-outline-secondary me-2" disabled>
                <i class="ri-refresh-line"></i> Reiniciar
              </button>
              <button id="btnSiguiente" class="btn btn-primary btn-lg" disabled>
                <i class="ri-arrow-right-line"></i> Siguiente Corte
              </button>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Panel de visualización del tablero -->
  <div class="row">
    <div class="col-12">
      <div class="card">
        <div class="card-body p-4">
          <div id="canvasContainer" class="position-relative bg-light rounded" style="min-height: 600px; display: flex; align-items: center; justify-content: center;">
            <canvas id="tableroCanvas" style="border: 2px solid #dee2e6; background: white; box-shadow: 0 4px 12px rgba(0,0,0,0.1); display: none;"></canvas>
            <div id="mensajeInicial" class="text-center text-muted">
              <i class="ri-information-line" style="font-size: 48px;"></i>
              <p class="mt-3 fs-5">Selecciona un tablero para comenzar</p>
            </div>
          </div>

          <div id="leyenda" class="mt-3 d-flex justify-content-center gap-4">
            <div class="d-flex align-items-center">
              <div style="width: 20px; height: 20px; background: #e3f2fd; border: 2px solid #2196f3;" class="me-2"></div>
              <span>Pieza a obtener</span>
            </div>
            <div class="d-flex align-items-center">
              <div style="width: 20px; height: 20px; background: #fff3e0; border: 2px solid #ff9800;" class="me-2"></div>
              <span>Sección activa</span>
            </div>
            <div class="d-flex align-items-center">
              <div style="width: 20px; height: 20px; background: #f5f5f5; border: 2px solid #9e9e9e;" class="me-2"></div>
              <span>En espera</span>
            </div>
            <div class="d-flex align-items-center">
              <div style="width: 3px; height: 20px; background: #f44336;" class="me-2"></div>
              <span>Línea de corte</span>
            </div>
            <div class="d-flex align-items-center">
              <div style="width: 3px; height: 20px; background: #9e9e9e;" class="me-2"></div>
              <span>Corte completado</span>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Modal de completado -->
  <div class="modal fade" id="modalCompletado" tabindex="-1">
    <div class="modal-dialog modal-dialog-centered">
      <div class="modal-content">
        <div class="modal-header bg-success text-white">
          <h5 class="modal-title"><i class="ri-checkbox-circle-line"></i> Tablero Completado</h5>
          <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal"></button>
        </div>
        <div class="modal-body text-center py-4">
          <i class="ri-checkbox-circle-fill text-success" style="font-size: 64px;"></i>
          <h4 class="mt-3">¡Todos los cortes completados!</h4>
          <p class="text-muted">Has terminado de cortar este tablero.</p>
        </div>
        <div class="modal-footer">
          <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cerrar</button>
          <button type="button" class="btn btn-primary" onclick="seleccionarOtroTablero()">Otro Tablero</button>
        </div>
      </div>
    </div>
  </div>
</div>

<style>
#tableroCanvas {
  cursor: default;
}
.progress {
  border-radius: 8px;
  overflow: hidden;
}
</style>

<script>
// ===== DATOS DEL PROYECTO =====
let proyectoData = null;
try {
  const rawData = '{{ proyecto.resultado_optimizacion|escapejs }}';
  if (rawData && rawData !== 'None' && rawData !== 'null') {
    proyectoData = JSON.parse(rawData);
  }
} catch(e) {
  console.error('Error parseando datos del proyecto:', e);
}

const proyectoId = {{ proyecto.id }};

// ===== ESTADO GLOBAL =====
let tableroActual = null;
let cortes = [];
let corteIndex = 0;
let canvas, ctx;
const SCALE = 0.3; // Escala para visualización (reducida para ver completo)
const PADDING = 30; // Padding del canvas

// ===== INICIALIZACIÓN =====
document.addEventListener('DOMContentLoaded', function() {
  canvas = document.getElementById('tableroCanvas');
  ctx = canvas.getContext('2d');
  
  console.log('Datos del proyecto:', proyectoData);
  
  cargarTableros();
  
  document.getElementById('tableroSelect').addEventListener('change', function() {
    const value = this.value;
    if (value) {
      cargarTablero(value);
    }
  });
  
  document.getElementById('btnSiguiente').addEventListener('click', siguienteCorte);
  document.getElementById('btnReiniciar').addEventListener('click', reiniciarTablero);
});

function cargarTableros() {
  const select = document.getElementById('tableroSelect');
  select.innerHTML = '<option value="">-- Selecciona un tablero --</option>';
  
  if (!proyectoData) {
    console.warn('No hay datos de optimización en el proyecto');
    const msg = document.createElement('div');
    msg.className = 'alert alert-warning mt-3';
    msg.innerHTML = '<i class="ri-alert-line"></i> Este proyecto no tiene resultados de optimización. Por favor, optimiza el proyecto primero desde la vista clásica.';
    document.getElementById('canvasContainer').innerHTML = '';
    document.getElementById('canvasContainer').appendChild(msg);
    return;
  }
  
  console.log('Estructura de datos:', proyectoData);
  
  // Iterar por materiales y sus tableros
  if (proyectoData.materiales && Array.isArray(proyectoData.materiales)) {
    proyectoData.materiales.forEach((material, matIdx) => {
      if (material.tableros && material.tableros.length > 0) {
        material.tableros.forEach((tablero, tabIdx) => {
          const option = document.createElement('option');
          option.value = JSON.stringify({matIdx, tabIdx});
          option.textContent = `Material ${matIdx + 1} - Tablero ${tablero.numero || (tabIdx + 1)} (${tablero.piezas ? tablero.piezas.length : 0} piezas)`;
          select.appendChild(option);
        });
      }
    });
  } else {
    console.warn('No se encontraron materiales en los datos');
  }
}

function cargarTablero(value) {
  try {
    const {matIdx, tabIdx} = JSON.parse(value);
    const material = proyectoData.materiales[matIdx];
    tableroActual = material.tableros[tabIdx];
    
    console.log('Tablero cargado:', tableroActual);
    
    // Ocultar mensaje inicial y mostrar canvas
    const mensajeInicial = document.getElementById('mensajeInicial');
    if (mensajeInicial) mensajeInicial.style.display = 'none';
    canvas.style.display = 'block';
    
    // Generar secuencia de cortes
    cortes = generarSecuenciaCortes(tableroActual);
    corteIndex = 0;
    
    console.log('Cortes generados:', cortes.length);
    
    // Actualizar UI
    document.getElementById('corteActual').textContent = '0';
    document.getElementById('totalCortes').textContent = cortes.length;
    document.getElementById('btnSiguiente').disabled = false;
    document.getElementById('btnReiniciar').disabled = false;
    
    // Dibujar estado inicial
    dibujarTablero();
  } catch(e) {
    console.error('Error cargando tablero:', e);
    alert('Error al cargar el tablero: ' + e.message);
  }
}

// ===== GENERACIÓN DE SECUENCIA DE CORTES =====
function generarSecuenciaCortes(tablero) {
  const piezas = tablero.piezas || [];
  const anchoTablero = tablero.ancho;
  const altoTablero = tablero.alto || tablero.largo;
  
  // Algoritmo guillotina: cortes rectos que dividen completamente una sección
  const secuencia = [];
  
  // Detectar si hay márgenes que cortar (piezas que no empiezan en 0,0)
  if (piezas.length > 0) {
    const minX = Math.min(...piezas.map(p => p.x || 0));
    const minY = Math.min(...piezas.map(p => p.y || 0));
    const maxX = Math.max(...piezas.map(p => (p.x || 0) + (p.ancho || 0)));
    const maxY = Math.max(...piezas.map(p => (p.y || 0) + ((p.alto || p.largo) || 0)));
    
    // Si hay margen superior o izquierdo
    if (minX > 0 || minY > 0 || maxX < anchoTablero || maxY < altoTablero) {
      const margenes = [];
      if (minX > 0) margenes.push(`izquierdo: ${Math.round(minX)}mm`);
      if (minY > 0) margenes.push(`superior: ${Math.round(minY)}mm`);
      if (maxX < anchoTablero) margenes.push(`derecho: ${Math.round(anchoTablero - maxX)}mm`);
      if (maxY < altoTablero) margenes.push(`inferior: ${Math.round(altoTablero - maxY)}mm`);
      
      secuencia.push({
        tipo: 'margen',
        descripcion: `⚠️ CORTAR MÁRGENES: ${margenes.join(', ')}`,
        esMargen: true
      });
    }
  }
  
  // Crear árbol de cortes usando algoritmo de guillotina recursivo
  function procesarSeccion(x, y, ancho, alto, piezasEnSeccion, nivel = 0) {
    if (piezasEnSeccion.length === 0) return;
    if (piezasEnSeccion.length === 1) {
      // Pieza final, no más cortes necesarios
      return;
    }
    
    // Intentar encontrar línea de corte horizontal
    const corteH = encontrarCorteHorizontal(piezasEnSeccion, y, alto);
    if (corteH) {
      secuencia.push({
        tipo: 'horizontal',
        x1: x,
        y: corteH.y,
        x2: x + ancho,
        descripcion: `Corte horizontal en Y=${Math.round(corteH.y)}mm`
      });
      
      // Dividir piezas en dos grupos
      const superior = piezasEnSeccion.filter(p => p.y < corteH.y);
      const inferior = piezasEnSeccion.filter(p => p.y >= corteH.y);
      
      // Procesar recursivamente
      if (superior.length > 0) {
        const altoSup = corteH.y - y;
        procesarSeccion(x, y, ancho, altoSup, superior, nivel + 1);
      }
      if (inferior.length > 0) {
        const yInf = corteH.y;
        const altoInf = (y + alto) - corteH.y;
        procesarSeccion(x, yInf, ancho, altoInf, inferior, nivel + 1);
      }
      return;
    }
    
    // Intentar encontrar línea de corte vertical
    const corteV = encontrarCorteVertical(piezasEnSeccion, x, ancho);
    if (corteV) {
      secuencia.push({
        tipo: 'vertical',
        x: corteV.x,
        y1: y,
        y2: y + alto,
        descripcion: `Corte vertical en X=${Math.round(corteV.x)}mm`
      });
      
      // Dividir piezas en dos grupos
      const izquierda = piezasEnSeccion.filter(p => p.x < corteV.x);
      const derecha = piezasEnSeccion.filter(p => p.x >= corteV.x);
      
      // Procesar recursivamente
      if (izquierda.length > 0) {
        const anchoIzq = corteV.x - x;
        procesarSeccion(x, y, anchoIzq, alto, izquierda, nivel + 1);
      }
      if (derecha.length > 0) {
        const xDer = corteV.x;
        const anchoDer = (x + ancho) - corteV.x;
        procesarSeccion(xDer, y, anchoDer, alto, derecha, nivel + 1);
      }
      return;
    }
  }
  
  // Iniciar procesamiento
  procesarSeccion(0, 0, anchoTablero, altoTablero, piezas, 0);
  
  return secuencia;
}

function encontrarCorteHorizontal(piezas, yBase, alto) {
  // Buscar una línea Y donde ninguna pieza la cruce
  const bordesY = new Set();
  piezas.forEach(p => {
    bordesY.add(p.y);
    bordesY.add(p.y + (p.alto || p.largo));
  });
  
  const bordesOrdenados = Array.from(bordesY).sort((a, b) => a - b);
  
  // Encontrar el primer borde que divida el conjunto
  for (let y of bordesOrdenados) {
    if (y <= yBase || y >= yBase + alto) continue;
    
    const superior = piezas.filter(p => p.y + (p.alto || p.largo) <= y);
    const inferior = piezas.filter(p => p.y >= y);
    
    if (superior.length > 0 && inferior.length > 0) {
      return {y, superior, inferior};
    }
  }
  
  return null;
}

function encontrarCorteVertical(piezas, xBase, ancho) {
  // Buscar una línea X donde ninguna pieza la cruce
  const bordesX = new Set();
  piezas.forEach(p => {
    bordesX.add(p.x);
    bordesX.add(p.x + p.ancho);
  });
  
  const bordesOrdenados = Array.from(bordesX).sort((a, b) => a - b);
  
  // Encontrar el primer borde que divida el conjunto
  for (let x of bordesOrdenados) {
    if (x <= xBase || x >= xBase + ancho) continue;
    
    const izquierda = piezas.filter(p => p.x + p.ancho <= x);
    const derecha = piezas.filter(p => p.x >= x);
    
    if (izquierda.length > 0 && derecha.length > 0) {
      return {x, izquierda, derecha};
    }
  }
  
  return null;
}

// ===== VISUALIZACIÓN =====
function dibujarTablero() {
  if (!tableroActual) {
    console.warn('No hay tablero actual para dibujar');
    return;
  }
  
  const anchoTablero = tableroActual.ancho;
  const altoTablero = tableroActual.alto || tableroActual.largo;
  const piezas = tableroActual.piezas || [];
  
  console.log('Dibujando tablero:', {ancho: anchoTablero, alto: altoTablero, piezas: piezas.length});
  
  // Ajustar tamaño del canvas con espacio extra para separaciones
  const espacioExtra = corteIndex * 40; // Espacio adicional para las separaciones
  const canvasWidth = anchoTablero * SCALE + PADDING * 2 + espacioExtra;
  const canvasHeight = altoTablero * SCALE + PADDING * 2 + espacioExtra;
  canvas.width = canvasWidth;
  canvas.height = canvasHeight;
  
  console.log('Canvas dimensiones:', {width: canvasWidth, height: canvasHeight});
  
  // Limpiar
  ctx.clearRect(0, 0, canvasWidth, canvasHeight);
  
  // Calcular secciones separadas según cortes realizados
  const secciones = calcularSecciones(piezas, cortes.slice(0, corteIndex));
  
  // Dibujar cada sección con separación visual
  secciones.forEach((seccion, secIdx) => {
    // Calcular offset para separación visual
    const offsetX = seccion.offsetX || 0;
    const offsetY = seccion.offsetY || 0;
    
    // Dibujar el rectángulo completo del área de la sección (incluyendo sobrantes)
    const secX = PADDING + seccion.x * SCALE + offsetX;
    const secY = PADDING + seccion.y * SCALE + offsetY;
    const secW = seccion.ancho * SCALE;
    const secH = seccion.alto * SCALE;
    
    // Fondo para toda la sección (área completa del tablero/sub-tablero)
    if (seccion.piezas.length === 0) {
      // Sección sin piezas = sobrante/desperdicio
      ctx.fillStyle = 'rgba(158, 158, 158, 0.2)'; // Gris claro para sobrantes
      ctx.fillRect(secX, secY, secW, secH);
      ctx.strokeStyle = '#9e9e9e';
      ctx.lineWidth = 1;
      ctx.setLineDash([5, 5]);
      ctx.strokeRect(secX, secY, secW, secH);
      ctx.setLineDash([]);
      
      // Etiqueta de sobrante
      ctx.fillStyle = '#757575';
      ctx.font = 'italic 11px Arial';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('Sobrante', secX + secW/2, secY + secH/2);
      ctx.fillText(`${Math.round(seccion.ancho)}×${Math.round(seccion.alto)}mm`, secX + secW/2, secY + secH/2 + 14);
      
      // Dibujar líneas de corte en cruz para indicar que se corta el sobrante
      ctx.strokeStyle = '#d32f2f';
      ctx.lineWidth = 2;
      ctx.setLineDash([10, 5]);
      ctx.beginPath();
      ctx.moveTo(secX, secY);
      ctx.lineTo(secX + secW, secY + secH);
      ctx.moveTo(secX + secW, secY);
      ctx.lineTo(secX, secY + secH);
      ctx.stroke();
      ctx.setLineDash([]);
      
      return;
    }
    
    // Fondo semi-transparente según estado
    if (seccion.activa) {
      ctx.fillStyle = 'rgba(255, 243, 224, 0.2)';
      ctx.fillRect(secX, secY, secW, secH);
    } else if (seccion.cortada) {
      ctx.fillStyle = 'rgba(227, 242, 253, 0.2)';
      ctx.fillRect(secX, secY, secW, secH);
    }
    
    // Borde de la sección completa
    ctx.strokeStyle = seccion.activa ? '#ff9800' : '#757575';
    ctx.lineWidth = seccion.activa ? 3 : 1.5;
    ctx.strokeRect(secX, secY, secW, secH);
    
    // Dibujar piezas de esta sección
    seccion.piezas.forEach((pieza, idx) => {
      // Las coordenadas de la pieza ya son relativas al origen del tablero
      const x = PADDING + (pieza.x || 0) * SCALE + offsetX;
      const y = PADDING + (pieza.y || 0) * SCALE + offsetY;
      const w = (pieza.ancho || 0) * SCALE;
      const h = ((pieza.alto || pieza.largo) || 0) * SCALE;
      
      if (w <= 0 || h <= 0) {
        console.warn('Pieza con dimensiones inválidas:', pieza);
        return;
      }
      
      // Relleno
      ctx.fillStyle = seccion.activa ? '#fff3e0' : '#e3f2fd';
      ctx.fillRect(x, y, w, h);
      
      // Borde
      ctx.strokeStyle = seccion.activa ? '#ff9800' : '#2196f3';
      ctx.lineWidth = 2;
      ctx.strokeRect(x, y, w, h);
      
      // Texto
      ctx.fillStyle = seccion.activa ? '#e65100' : '#1565c0';
      ctx.font = '12px Arial';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      const nombrePieza = pieza.nombre || `Pieza ${pieza.numero || idx + 1}`;
      ctx.fillText(nombrePieza, x + w/2, y + h/2);
      
      // Dimensiones
      ctx.font = '10px Arial';
      ctx.fillStyle = '#666';
      const dim = `${Math.round(pieza.ancho || 0)}×${Math.round((pieza.alto || pieza.largo) || 0)}`;
      ctx.fillText(dim, x + w/2, y + h/2 + 15);
    });
  });
  
  // Dibujar cortes realizados (con separación visual)
  for (let i = 0; i < corteIndex; i++) {
    if (!cortes[i].esMargen) {
      dibujarCorteConSeparacion(cortes[i], i, '#9e9e9e', 2);
    }
  }
  
  // Dibujar corte actual (en rojo destacado) solo en la sección activa
  // NO dibujar si es un margen (solo mostrar instrucción)
  if (corteIndex < cortes.length && !cortes[corteIndex].esMargen) {
    const seccionActiva = secciones.find(s => s.activa);
    if (seccionActiva) {
      dibujarCorteActual(cortes[corteIndex], '#f44336', 4, seccionActiva);
    }
  }
  
  // Actualizar contador
  document.getElementById('corteActual').textContent = corteIndex;
  const progreso = cortes.length > 0 ? Math.round((corteIndex / cortes.length) * 100) : 0;
  document.getElementById('progressBar').style.width = progreso + '%';
  document.getElementById('progressBar').textContent = progreso + '%';
  
  // Notificación de margen en el centro del canvas
  if (corteIndex < cortes.length && cortes[corteIndex].esMargen) {
    const centerX = canvasWidth / 2;
    const centerY = canvasHeight / 2;
    
    // Fondo semi-transparente
    ctx.fillStyle = 'rgba(255, 152, 0, 0.95)';
    ctx.roundRect = function(x, y, w, h, r) {
      this.beginPath();
      this.moveTo(x + r, y);
      this.lineTo(x + w - r, y);
      this.arcTo(x + w, y, x + w, y + r, r);
      this.lineTo(x + w, y + h - r);
      this.arcTo(x + w, y + h, x + w - r, y + h, r);
      this.lineTo(x + r, y + h);
      this.arcTo(x, y + h, x, y + h - r, r);
      this.lineTo(x, y + r);
      this.arcTo(x, y, x + r, y, r);
      this.closePath();
    };
    
    ctx.roundRect(centerX - 150, centerY - 40, 300, 80, 10);
    ctx.fill();
    
    // Borde
    ctx.strokeStyle = '#f57c00';
    ctx.lineWidth = 2;
    ctx.roundRect(centerX - 150, centerY - 40, 300, 80, 10);
    ctx.stroke();
    
    // Texto
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 14px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('⚠️ PASO PREVIO', centerX, centerY - 15);
    ctx.font = '12px Arial';
    ctx.fillText('Cortar márgenes antes de continuar', centerX, centerY + 10);
  }
}

// Calcular secciones del tablero según cortes realizados
function calcularSecciones(piezas, cortesRealizados) {
  const GAP = 15; // Separación visual entre secciones
  
  if (cortesRealizados.length === 0) {
    // Tablero completo sin cortes
    return [{
      x: 0,
      y: 0,
      ancho: tableroActual.ancho,
      alto: tableroActual.alto || tableroActual.largo,
      piezas: piezas,
      activa: true,
      cortada: false,
      offsetX: 0,
      offsetY: 0,
      terminada: false
    }];
  }
  
  // Aplicar cortes de forma secuencial, manteniendo el historial de qué secciones están terminadas
  let secciones = [{
    minX: 0,
    minY: 0,
    maxX: tableroActual.ancho,
    maxY: tableroActual.alto || tableroActual.largo,
    piezas: piezas,
    offsetX: 0,
    offsetY: 0,
    terminada: false,
    nivel: 0
  }];
  
  cortesRealizados.forEach((corte, corteIdx) => {
    // Saltar cortes de margen (no modifican la geometría, solo son instrucciones)
    if (corte.esMargen) {
      return;
    }
    
    const nuevasSecciones = [];
    const separacion = GAP;
    
    // Solo procesar la primera sección no terminada (la que está activa)
    let corteAplicado = false;
    
    secciones.forEach((seccion, secIdx) => {
      // Si ya está terminada (solo tiene 1 pieza o menos), mantenerla intacta
      if (seccion.terminada || seccion.piezas.length <= 1) {
        nuevasSecciones.push({...seccion, terminada: true});
        return;
      }
      
      // Si ya aplicamos el corte a una sección activa, mantener esta intacta
      if (corteAplicado) {
        nuevasSecciones.push(seccion);
        return;
      }
      
      // Intentar aplicar el corte a esta sección activa
      let corteDividio = false;
      
      if (corte.tipo === 'horizontal') {
        // Verificar si el corte atraviesa esta sección
        if (corte.y > seccion.minY && corte.y < seccion.maxY) {
          const piezasSup = seccion.piezas.filter(p => {
            const py = p.y || 0;
            const pAlto = (p.alto || p.largo) || 0;
            return (py + pAlto) <= corte.y;
          });
          
          const piezasInf = seccion.piezas.filter(p => {
            const py = p.y || 0;
            return py >= corte.y;
          });
          
          // Solo dividir si ambas partes tienen piezas
          if (piezasSup.length > 0 && piezasInf.length > 0) {
            corteDividio = true;
            corteAplicado = true;
            
            nuevasSecciones.push({
              minX: seccion.minX,
              minY: seccion.minY,
              maxX: seccion.maxX,
              maxY: corte.y,
              piezas: piezasSup,
              offsetX: seccion.offsetX,
              offsetY: seccion.offsetY - separacion,
              terminada: piezasSup.length <= 1,
              nivel: seccion.nivel + 1
            });
            
            nuevasSecciones.push({
              minX: seccion.minX,
              minY: corte.y,
              maxX: seccion.maxX,
              maxY: seccion.maxY,
              piezas: piezasInf,
              offsetX: seccion.offsetX,
              offsetY: seccion.offsetY + separacion,
              terminada: piezasInf.length <= 1,
              nivel: seccion.nivel + 1
            });
          }
        }
      } else {
        // Corte vertical
        if (corte.x > seccion.minX && corte.x < seccion.maxX) {
          const piezasIzq = seccion.piezas.filter(p => {
            const px = p.x || 0;
            const pAncho = p.ancho || 0;
            return (px + pAncho) <= corte.x;
          });
          
          const piezasDer = seccion.piezas.filter(p => {
            const px = p.x || 0;
            return px >= corte.x;
          });
          
          // Solo dividir si ambas partes tienen piezas
          if (piezasIzq.length > 0 && piezasDer.length > 0) {
            corteDividio = true;
            corteAplicado = true;
            
            nuevasSecciones.push({
              minX: seccion.minX,
              minY: seccion.minY,
              maxX: corte.x,
              maxY: seccion.maxY,
              piezas: piezasIzq,
              offsetX: seccion.offsetX - separacion,
              offsetY: seccion.offsetY,
              terminada: piezasIzq.length <= 1,
              nivel: seccion.nivel + 1
            });
            
            nuevasSecciones.push({
              minX: corte.x,
              minY: seccion.minY,
              maxX: seccion.maxX,
              maxY: seccion.maxY,
              piezas: piezasDer,
              offsetX: seccion.offsetX + separacion,
              offsetY: seccion.offsetY,
              terminada: piezasDer.length <= 1,
              nivel: seccion.nivel + 1
            });
          }
        }
      }
      
      // Si no se aplicó el corte, mantener la sección tal cual
      if (!corteDividio) {
        nuevasSecciones.push(seccion);
      }
    });
    
    secciones = nuevasSecciones;
  });
  
  // Convertir a formato de salida y marcar la primera sección no terminada como activa
  let activaMarcada = false;
  return secciones.map((sec, idx) => {
    const esActiva = !activaMarcada && !sec.terminada && sec.piezas.length > 1;
    if (esActiva) activaMarcada = true;
    
    return {
      x: sec.minX,
      y: sec.minY,
      ancho: sec.maxX - sec.minX,
      alto: sec.maxY - sec.minY,
      piezas: sec.piezas,
      offsetX: sec.offsetX,
      offsetY: sec.offsetY,
      activa: esActiva && corteIndex < cortes.length,
      cortada: sec.terminada || sec.piezas.length === 1,
      terminada: sec.terminada
    };
  });
}

function dibujarCorteConSeparacion(corte, indice, color, lineWidth) {
  // Los cortes completados se muestran en las separaciones
  // No dibujar línea porque ya están separados visualmente
}

function dibujarCorteActual(corte, color, lineWidth, seccionActiva) {
  ctx.strokeStyle = color;
  ctx.lineWidth = lineWidth;
  ctx.setLineDash([5, 5]); // Línea punteada para el corte actual
  
  const offsetX = seccionActiva ? (seccionActiva.offsetX || 0) : 0;
  const offsetY = seccionActiva ? (seccionActiva.offsetY || 0) : 0;
  
  if (corte.tipo === 'horizontal') {
    const x1 = PADDING + corte.x1 * SCALE + offsetX;
    const x2 = PADDING + corte.x2 * SCALE + offsetX;
    const y = PADDING + corte.y * SCALE + offsetY;
    
    ctx.beginPath();
    ctx.moveTo(x1, y);
    ctx.lineTo(x2, y);
    ctx.stroke();
    
    // Flechas en los extremos
    ctx.setLineDash([]);
    dibujarFlecha(ctx, x1 + 10, y, -10, 0);
    dibujarFlecha(ctx, x2 - 10, y, 10, 0);
  } else {
    const x = PADDING + corte.x * SCALE + offsetX;
    const y1 = PADDING + corte.y1 * SCALE + offsetY;
    const y2 = PADDING + corte.y2 * SCALE + offsetY;
    
    ctx.beginPath();
    ctx.moveTo(x, y1);
    ctx.lineTo(x, y2);
    ctx.stroke();
    
    // Flechas en los extremos
    ctx.setLineDash([]);
    dibujarFlecha(ctx, x, y1 + 10, 0, -10);
    dibujarFlecha(ctx, x, y2 - 10, 0, 10);
  }
  
  ctx.setLineDash([]); // Restaurar línea sólida
}

function dibujarFlecha(ctx, x, y, dx, dy) {
  const tam = 8;
  ctx.save();
  ctx.translate(x + dx, y + dy);
  
  if (dx !== 0) {
    const dir = dx > 0 ? 1 : -1;
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.lineTo(-dir * tam, -tam/2);
    ctx.lineTo(-dir * tam, tam/2);
    ctx.closePath();
    ctx.fill();
  } else {
    const dir = dy > 0 ? 1 : -1;
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.lineTo(-tam/2, -dir * tam);
    ctx.lineTo(tam/2, -dir * tam);
    ctx.closePath();
    ctx.fill();
  }
  
  ctx.restore();
}

// ===== NAVEGACIÓN =====
function siguienteCorte() {
  if (corteIndex < cortes.length) {
    corteIndex++;
    dibujarTablero();
    
    if (corteIndex >= cortes.length) {
      // Completado
      document.getElementById('btnSiguiente').disabled = true;
      mostrarModalCompletado();
    }
  }
}

function reiniciarTablero() {
  corteIndex = 0;
  document.getElementById('btnSiguiente').disabled = false;
  dibujarTablero();
}

function mostrarModalCompletado() {
  const modal = new bootstrap.Modal(document.getElementById('modalCompletado'));
  modal.show();
}

function seleccionarOtroTablero() {
  const modal = bootstrap.Modal.getInstance(document.getElementById('modalCompletado'));
  modal.hide();
  document.getElementById('tableroSelect').focus();
}
</script>
{% endblock %}
