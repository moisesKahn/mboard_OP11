{% extends 'layout/layout.html' %}
{% load static %}

{% block content %}
<div class="container-fluid">
  <div class="d-flex justify-content-between align-items-center mb-2">
    <div class="d-flex align-items-center gap-2">
      <a href="{% url 'operador_home' %}" class="btn btn-sm btn-outline-secondary">
        <i class="ri-arrow-left-line"></i> Volver
      </a>
      <span class="fw-semibold">{{ proyecto.nombre }}</span>
      <span class="text-muted small">| #{{ proyecto.public_id|default:proyecto.id }} | {{ proyecto.cliente.nombre }}</span>
    </div>
  </div>

  <!-- Panel de control superior compacto -->
  <div class="card mb-2">
    <div class="card-body py-2 px-3">
      <div class="d-flex align-items-center gap-3 flex-wrap">
        <div style="min-width:220px">
          <select id="tableroSelect" class="form-select form-select-sm">
            <option value="">-- Selecciona un tablero --</option>
          </select>
        </div>
        <div class="d-flex align-items-center gap-1">
          <span class="text-muted small">Corte:</span>
          <span class="fw-bold" id="corteActual">-</span>
          <span class="text-muted small">/ <span id="totalCortes">-</span></span>
        </div>
        <div class="flex-grow-1" style="min-width:120px">
          <div class="progress" style="height:18px">
            <div id="progressBar" class="progress-bar bg-success" role="progressbar" style="width:0%">0%</div>
          </div>
        </div>
        <div class="d-flex gap-2 ms-auto">
          <button id="btnReiniciar" class="btn btn-sm btn-outline-secondary" disabled>
            <i class="ri-refresh-line"></i> Reiniciar
          </button>
          <button id="btnSiguiente" class="btn btn-sm btn-primary" disabled>
            <i class="ri-arrow-right-line"></i> Siguiente Corte
          </button>
        </div>
      </div>
    </div>
  </div>

  <!-- Panel de visualización del tablero -->
  <div class="row">
    <div class="col-12">
      <div class="card">
        <div class="card-body p-4">
          <div id="canvasContainer" class="position-relative bg-light rounded" style="min-height: 400px; display: flex; align-items: center; justify-content: center;">
            <canvas id="tableroCanvas" style="border: 2px solid #dee2e6; background: white; box-shadow: 0 4px 12px rgba(0,0,0,0.1); display: none;"></canvas>
            <div id="mensajeInicial" class="text-center text-muted">
              <i class="ri-information-line" style="font-size: 48px;"></i>
              <p class="mt-3 fs-5">Selecciona un tablero para comenzar</p>
            </div>
          </div>

          <div id="leyenda" class="mt-3 d-flex justify-content-center gap-4">
            <div class="d-flex align-items-center">
              <div style="width: 20px; height: 20px; background: #e3f2fd; border: 2px solid #2196f3;" class="me-2"></div>
              <span>Pieza a obtener</span>
            </div>
            <div class="d-flex align-items-center">
              <div style="width: 20px; height: 20px; background: #fff3e0; border: 2px solid #ff9800;" class="me-2"></div>
              <span>Sección activa</span>
            </div>
            <div class="d-flex align-items-center">
              <div style="width: 20px; height: 20px; background: #f5f5f5; border: 2px solid #9e9e9e;" class="me-2"></div>
              <span>En espera</span>
            </div>
            <div class="d-flex align-items-center">
              <div style="width: 3px; height: 20px; background: #f44336;" class="me-2"></div>
              <span>Línea de corte</span>
            </div>
            <div class="d-flex align-items-center">
              <div style="width: 3px; height: 20px; background: #9e9e9e;" class="me-2"></div>
              <span>Corte completado</span>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Modal de completado -->
  <div class="modal fade" id="modalCompletado" tabindex="-1">
    <div class="modal-dialog modal-dialog-centered">
      <div class="modal-content">
        <div class="modal-header bg-success text-white">
          <h5 class="modal-title"><i class="ri-checkbox-circle-line"></i> Tablero Completado</h5>
          <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal"></button>
        </div>
        <div class="modal-body text-center py-4">
          <i class="ri-checkbox-circle-fill text-success" style="font-size: 64px;"></i>
          <h4 class="mt-3">¡Todos los cortes completados!</h4>
          <p class="text-muted">Has terminado de cortar este tablero.</p>
        </div>
        <div class="modal-footer">
          <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cerrar</button>
          <button type="button" class="btn btn-primary" onclick="seleccionarOtroTablero()">Otro Tablero</button>
        </div>
      </div>
    </div>
  </div>
</div>

<style>
#tableroCanvas {
  cursor: default;
}
.progress {
  border-radius: 8px;
  overflow: hidden;
}
</style>

<script>
// ===== DATOS DEL PROYECTO =====
let proyectoData = null;
try {
  const rawData = '{{ proyecto.resultado_optimizacion|escapejs }}';
  if (rawData && rawData !== 'None' && rawData !== 'null') {
    proyectoData = JSON.parse(rawData);
  }
} catch(e) {
  console.error('Error parseando datos del proyecto:', e);
}

const proyectoId = {{ proyecto.id }};

// ===== ESTADO GLOBAL =====
let tableroActual = null;
let cortes = [];
let corteIndex = 0;
let canvas, ctx;
const SCALE = 0.3; // Escala para visualización (reducida para ver completo)
const PADDING = 30; // Padding del canvas

// ===== INICIALIZACIÓN =====
document.addEventListener('DOMContentLoaded', function() {
  canvas = document.getElementById('tableroCanvas');
  ctx = canvas.getContext('2d');
  
  console.log('Datos del proyecto:', proyectoData);
  
  cargarTableros();
  
  document.getElementById('tableroSelect').addEventListener('change', function() {
    const value = this.value;
    if (value) {
      cargarTablero(value);
    }
  });
  
  document.getElementById('btnSiguiente').addEventListener('click', siguienteCorte);
  document.getElementById('btnReiniciar').addEventListener('click', reiniciarTablero);
});

function cargarTableros() {
  const select = document.getElementById('tableroSelect');
  select.innerHTML = '<option value="">-- Selecciona un tablero --</option>';
  
  if (!proyectoData) {
    console.warn('No hay datos de optimización en el proyecto');
    const msg = document.createElement('div');
    msg.className = 'alert alert-warning mt-3';
    msg.innerHTML = '<i class="ri-alert-line"></i> Este proyecto no tiene resultados de optimización. Por favor, optimiza el proyecto primero desde la vista clásica.';
    document.getElementById('canvasContainer').innerHTML = '';
    document.getElementById('canvasContainer').appendChild(msg);
    return;
  }
  
  console.log('Estructura de datos:', proyectoData);
  
  // Iterar por materiales y sus tableros
  if (proyectoData.materiales && Array.isArray(proyectoData.materiales)) {
    proyectoData.materiales.forEach((material, matIdx) => {
      if (material.tableros && material.tableros.length > 0) {
        material.tableros.forEach((tablero, tabIdx) => {
          const option = document.createElement('option');
          option.value = JSON.stringify({matIdx, tabIdx});
          option.textContent = `Material ${matIdx + 1} - Tablero ${tablero.numero || (tabIdx + 1)} (${tablero.piezas ? tablero.piezas.length : 0} piezas)`;
          select.appendChild(option);
        });
      }
    });
  } else {
    console.warn('No se encontraron materiales en los datos');
  }
}

function cargarTablero(value) {
  try {
    const {matIdx, tabIdx} = JSON.parse(value);
    const material = proyectoData.materiales[matIdx];
    tableroActual = material.tableros[tabIdx];
    
    console.log('Tablero cargado:', tableroActual);
    
    // Ocultar mensaje inicial y mostrar canvas
    const mensajeInicial = document.getElementById('mensajeInicial');
    if (mensajeInicial) mensajeInicial.style.display = 'none';
    canvas.style.display = 'block';
    
    // Generar secuencia de cortes
    cortes = generarSecuenciaCortes(tableroActual);
    corteIndex = 0;
    
    console.log('Cortes generados:', cortes.length);
    
    // Actualizar UI
    document.getElementById('corteActual').textContent = '0';
    document.getElementById('totalCortes').textContent = cortes.length;
    document.getElementById('btnSiguiente').disabled = false;
    document.getElementById('btnReiniciar').disabled = false;
    
    // Dibujar estado inicial
    dibujarTablero();
  } catch(e) {
    console.error('Error cargando tablero:', e);
    alert('Error al cargar el tablero: ' + e.message);
  }
}

// ===== GENERACIÓN DE SECUENCIA DE CORTES =====
function generarSecuenciaCortes(tablero) {
  const piezas = tablero.piezas || [];
  const anchoTablero = tablero.ancho;
  const altoTablero = tablero.alto || tablero.largo;
  
  // Algoritmo guillotina: cortes rectos que dividen completamente una sección
  const secuencia = [];
  
  // Detectar si hay márgenes que cortar (piezas que no empiezan en 0,0)
  if (piezas.length > 0) {
    const minX = Math.min(...piezas.map(p => p.x || 0));
    const minY = Math.min(...piezas.map(p => p.y || 0));
    const maxX = Math.max(...piezas.map(p => (p.x || 0) + (p.ancho || 0)));
    const maxY = Math.max(...piezas.map(p => (p.y || 0) + ((p.alto || p.largo) || 0)));
    
    // Si hay margen superior o izquierdo
    if (minX > 0 || minY > 0 || maxX < anchoTablero || maxY < altoTablero) {
      const margenes = [];
      if (minX > 0) margenes.push(`izquierdo: ${Math.round(minX)}mm`);
      if (minY > 0) margenes.push(`superior: ${Math.round(minY)}mm`);
      if (maxX < anchoTablero) margenes.push(`derecho: ${Math.round(anchoTablero - maxX)}mm`);
      if (maxY < altoTablero) margenes.push(`inferior: ${Math.round(altoTablero - maxY)}mm`);
      
      secuencia.push({
        tipo: 'margen',
        descripcion: `⚠️ CORTAR MÁRGENES: ${margenes.join(', ')}`,
        esMargen: true
      });
    }
  }
  
  // Crear árbol de cortes usando algoritmo de guillotina recursivo
  // Estrategia optimizada para maximizar sobrantes:
  // 1. Primero separar sobrante derecho completo (si existe)
  // 2. Luego separar sobrante inferior completo (si existe)
  // 3. Luego dividir por filas horizontales
  // 4. Finalmente dividir cada fila en columnas verticales
  function procesarSeccion(x, y, ancho, alto, piezasEnSeccion, nivel = 0) {
    if (piezasEnSeccion.length === 0) return;
    if (piezasEnSeccion.length === 1) {
      // Una sola pieza: separar sobrante derecho si lo hay
      const p = piezasEnSeccion[0];
      const bordeDerechoPieza = p.x + (p.ancho || 0);
      const bordeInferiorPieza = p.y + (p.alto || p.largo || 0);
      if (bordeDerechoPieza < x + ancho - 1) {
        secuencia.push({
          tipo: 'vertical',
          x: bordeDerechoPieza,
          y1: y,
          y2: y + alto,
          descripcion: `Corte vertical en X=${Math.round(bordeDerechoPieza)}mm (separar sobrante derecho)`
        });
      }
      if (bordeInferiorPieza < y + alto - 1) {
        secuencia.push({
          tipo: 'horizontal',
          x1: x,
          y: bordeInferiorPieza,
          x2: x + ancho,
          descripcion: `Corte horizontal en Y=${Math.round(bordeInferiorPieza)}mm (separar sobrante inferior)`
        });
      }
      return;
    }

    // === PASO 1: Separar sobrante derecho completo ===
    // Si ninguna pieza llega al borde derecho de la sección, hacer corte vertical ahí
    const maxXPiezas = Math.max(...piezasEnSeccion.map(p => p.x + (p.ancho || 0)));
    if (maxXPiezas < x + ancho - 1) {
      secuencia.push({
        tipo: 'vertical',
        x: maxXPiezas,
        y1: y,
        y2: y + alto,
        descripcion: `Corte vertical en X=${Math.round(maxXPiezas)}mm (separar sobrante derecho)`
      });
      // Continuar solo con la zona útil
      ancho = maxXPiezas - x;
    }

    // === PASO 2: Separar sobrante inferior completo ===
    const maxYPiezas = Math.max(...piezasEnSeccion.map(p => p.y + (p.alto || p.largo || 0)));
    if (maxYPiezas < y + alto - 1) {
      secuencia.push({
        tipo: 'horizontal',
        x1: x,
        y: maxYPiezas,
        x2: x + ancho,
        descripcion: `Corte horizontal en Y=${Math.round(maxYPiezas)}mm (separar sobrante inferior)`
      });
      // Continuar solo con la zona útil
      alto = maxYPiezas - y;
    }

    // === PASO 3: Buscar corte horizontal que divida filas ===
    const corteH = encontrarCorteHorizontal(piezasEnSeccion, y, alto);
    if (corteH) {
      secuencia.push({
        tipo: 'horizontal',
        x1: x,
        y: corteH.y,
        x2: x + ancho,
        descripcion: `Corte horizontal en Y=${Math.round(corteH.y)}mm`
      });
      const superior = piezasEnSeccion.filter(p => p.y + (p.alto || p.largo) <= corteH.y);
      const inferior = piezasEnSeccion.filter(p => p.y >= corteH.y);
      if (superior.length > 0) procesarSeccion(x, y, ancho, corteH.y - y, superior, nivel + 1);
      if (inferior.length > 0) procesarSeccion(x, corteH.y, ancho, (y + alto) - corteH.y, inferior, nivel + 1);
      return;
    }

    // === PASO 4: Buscar corte vertical que divida columnas ===
    const corteV = encontrarCorteVertical(piezasEnSeccion, x, ancho);
    if (corteV) {
      secuencia.push({
        tipo: 'vertical',
        x: corteV.x,
        y1: y,
        y2: y + alto,
        descripcion: `Corte vertical en X=${Math.round(corteV.x)}mm`
      });
      const izquierda = piezasEnSeccion.filter(p => p.x + p.ancho <= corteV.x);
      const derecha   = piezasEnSeccion.filter(p => p.x >= corteV.x);
      if (izquierda.length > 0) procesarSeccion(x, y, corteV.x - x, alto, izquierda, nivel + 1);
      if (derecha.length > 0)   procesarSeccion(corteV.x, y, (x + ancho) - corteV.x, alto, derecha, nivel + 1);
      return;
    }
  }

  // Iniciar procesamiento
  procesarSeccion(0, 0, anchoTablero, altoTablero, piezas, 0);

  return secuencia;
}

function encontrarCorteHorizontal(piezas, yBase, alto) {
  // Buscar una línea Y donde ninguna pieza la cruce
  const bordesY = new Set();
  piezas.forEach(p => {
    bordesY.add(p.y);
    bordesY.add(p.y + (p.alto || p.largo));
  });
  
  const bordesOrdenados = Array.from(bordesY).sort((a, b) => a - b);
  
  // Encontrar el primer borde que divida el conjunto
  for (let y of bordesOrdenados) {
    if (y <= yBase || y >= yBase + alto) continue;
    
    const superior = piezas.filter(p => p.y + (p.alto || p.largo) <= y);
    const inferior = piezas.filter(p => p.y >= y);
    
    if (superior.length > 0 && inferior.length > 0) {
      return {y, superior, inferior};
    }
  }
  
  return null;
}

function encontrarCorteVertical(piezas, xBase, ancho) {
  // Buscar una línea X donde ninguna pieza la cruce
  const bordesX = new Set();
  piezas.forEach(p => {
    bordesX.add(p.x);
    bordesX.add(p.x + p.ancho);
  });
  
  const bordesOrdenados = Array.from(bordesX).sort((a, b) => a - b);
  
  // Encontrar el primer borde que divida el conjunto
  for (let x of bordesOrdenados) {
    if (x <= xBase || x >= xBase + ancho) continue;
    
    const izquierda = piezas.filter(p => p.x + p.ancho <= x);
    const derecha = piezas.filter(p => p.x >= x);
    
    if (izquierda.length > 0 && derecha.length > 0) {
      return {x, izquierda, derecha};
    }
  }
  
  return null;
}

// ===== LAYOUT ENGINE =====
// Calcula posiciones de render (renderX, renderY) para cada sección a partir de sus
// coordenadas lógicas. Las secciones se organizan en filas y columnas únicas, y se
// inserta un GAP visual entre ellas.
function calcularLayout(secciones) {
  const GAP = 15;
  // Obtener los valores únicos de minY (filas) y minX (columnas), ordenados
  const filasUnicas = [...new Set(secciones.map(s => s.y))].sort((a, b) => a - b);
  const colsUnicas  = [...new Set(secciones.map(s => s.x))].sort((a, b) => a - b);

  // Para cada fila/columna calculamos el offset acumulado de gaps
  // La sección en la fila i se desplaza i * GAP en Y (respecto a la posición lógica)
  // La sección en la columna j se desplaza j * GAP en X
  const gapPorFila = {};
  filasUnicas.forEach((y, i) => { gapPorFila[y] = i * GAP; });
  const gapPorCol  = {};
  colsUnicas.forEach((x, j) => { gapPorCol[x]  = j * GAP; });

  return secciones.map(sec => ({
    ...sec,
    renderX: PADDING + sec.x * SCALE + (gapPorCol[sec.x]  || 0),
    renderY: PADDING + sec.y * SCALE + (gapPorFila[sec.y] || 0),
  }));
}

// ===== VISUALIZACIÓN =====
function dibujarTablero() {
  if (!tableroActual) {
    console.warn('No hay tablero actual para dibujar');
    return;
  }
  
  const anchoTablero = tableroActual.ancho;
  const altoTablero = tableroActual.alto || tableroActual.largo;
  const piezas = tableroActual.piezas || [];
  
  // Calcular secciones separadas según cortes realizados
  const seccionesBase = calcularSecciones(piezas, cortes.slice(0, corteIndex));
  const secciones = calcularLayout(seccionesBase);
  
  // Calcular tamaño del canvas en función del layout real
  let maxRX = 0, maxRY = 0;
  secciones.forEach(sec => {
    maxRX = Math.max(maxRX, sec.renderX + sec.ancho * SCALE);
    maxRY = Math.max(maxRY, sec.renderY + sec.alto  * SCALE);
  });
  const canvasWidth  = maxRX + PADDING;
  const canvasHeight = maxRY + PADDING;
  canvas.width  = canvasWidth;
  canvas.height = canvasHeight;
  
  // Limpiar
  ctx.clearRect(0, 0, canvasWidth, canvasHeight);
  
  // Dibujar cada sección con su posición de render
  secciones.forEach((seccion) => {
    const secX = seccion.renderX;
    const secY = seccion.renderY;
    const secW = seccion.ancho * SCALE;
    const secH = seccion.alto  * SCALE;
    
    if (seccion.piezas.length === 0) {
      // Sobrante / desperdicio
      ctx.fillStyle = 'rgba(158, 158, 158, 0.2)';
      ctx.fillRect(secX, secY, secW, secH);
      ctx.strokeStyle = '#9e9e9e';
      ctx.lineWidth = 1;
      ctx.setLineDash([5, 5]);
      ctx.strokeRect(secX, secY, secW, secH);
      ctx.setLineDash([]);
      
      ctx.fillStyle = '#757575';
      ctx.font = 'italic 11px Arial';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('Sobrante', secX + secW/2, secY + secH/2);
      ctx.fillText(`${Math.round(seccion.ancho)}×${Math.round(seccion.alto)}mm`, secX + secW/2, secY + secH/2 + 14);
      
      ctx.strokeStyle = '#d32f2f';
      ctx.lineWidth = 2;
      ctx.setLineDash([10, 5]);
      ctx.beginPath();
      ctx.moveTo(secX, secY);
      ctx.lineTo(secX + secW, secY + secH);
      ctx.moveTo(secX + secW, secY);
      ctx.lineTo(secX, secY + secH);
      ctx.stroke();
      ctx.setLineDash([]);
      return;
    }
    
    // Fondo según estado
    if (seccion.activa) {
      ctx.fillStyle = 'rgba(255, 243, 224, 0.2)';
      ctx.fillRect(secX, secY, secW, secH);
    } else if (seccion.cortada) {
      ctx.fillStyle = 'rgba(227, 242, 253, 0.2)';
      ctx.fillRect(secX, secY, secW, secH);
    }
    
    // Borde de la sección
    ctx.strokeStyle = seccion.activa ? '#ff9800' : '#757575';
    ctx.lineWidth   = seccion.activa ? 3 : 1.5;
    ctx.strokeRect(secX, secY, secW, secH);
    
    // Piezas
    seccion.piezas.forEach((pieza, idx) => {
      // Offset de la pieza dentro de su sección (relativo al origen de la sección lógica)
      const px = seccion.renderX + (pieza.x - seccion.x) * SCALE;
      const py = seccion.renderY + ((pieza.y !== undefined ? pieza.y : 0) - seccion.y) * SCALE;
      const pw = (pieza.ancho || 0) * SCALE;
      const ph = ((pieza.alto || pieza.largo) || 0) * SCALE;
      
      if (pw <= 0 || ph <= 0) return;
      
      ctx.fillStyle   = seccion.activa ? '#fff3e0' : '#e3f2fd';
      ctx.fillRect(px, py, pw, ph);
      
      ctx.strokeStyle = seccion.activa ? '#ff9800' : '#2196f3';
      ctx.lineWidth   = 2;
      ctx.strokeRect(px, py, pw, ph);
      
      ctx.fillStyle     = seccion.activa ? '#e65100' : '#1565c0';
      ctx.font          = '12px Arial';
      ctx.textAlign     = 'center';
      ctx.textBaseline  = 'middle';
      const nombre = pieza.nombre || `Pieza ${pieza.numero || idx + 1}`;
      ctx.fillText(nombre, px + pw/2, py + ph/2);
      
      ctx.font      = '10px Arial';
      ctx.fillStyle = '#666';
      const dim = `${Math.round(pieza.ancho || 0)}×${Math.round((pieza.alto || pieza.largo) || 0)}`;
      ctx.fillText(dim, px + pw/2, py + ph/2 + 15);
    });
  });
  
  // Dibujar corte actual (en rojo) en la sección activa
  if (corteIndex < cortes.length && !cortes[corteIndex].esMargen) {
    const seccionActiva = secciones.find(s => s.activa);
    if (seccionActiva) {
      dibujarCorteActual(cortes[corteIndex], '#f44336', 4, seccionActiva);
    }
  }
  
  // Actualizar contador y barra de progreso
  document.getElementById('corteActual').textContent = corteIndex;
  const progreso = cortes.length > 0 ? Math.round((corteIndex / cortes.length) * 100) : 0;
  document.getElementById('progressBar').style.width   = progreso + '%';
  document.getElementById('progressBar').textContent   = progreso + '%';
  
  // Notificación de margen en el centro del canvas
  if (corteIndex < cortes.length && cortes[corteIndex].esMargen) {
    const centerX = canvasWidth  / 2;
    const centerY = canvasHeight / 2;
    
    ctx.fillStyle = 'rgba(255, 152, 0, 0.95)';
    const drawRRect = (x, y, w, h, r) => {
      ctx.beginPath();
      ctx.moveTo(x + r, y);
      ctx.lineTo(x + w - r, y);
      ctx.arcTo(x + w, y, x + w, y + r, r);
      ctx.lineTo(x + w, y + h - r);
      ctx.arcTo(x + w, y + h, x + w - r, y + h, r);
      ctx.lineTo(x + r, y + h);
      ctx.arcTo(x, y + h, x, y + h - r, r);
      ctx.lineTo(x, y + r);
      ctx.arcTo(x, y, x + r, y, r);
      ctx.closePath();
    };
    drawRRect(centerX - 150, centerY - 40, 300, 80, 10);
    ctx.fill();
    ctx.strokeStyle = '#f57c00';
    ctx.lineWidth   = 2;
    drawRRect(centerX - 150, centerY - 40, 300, 80, 10);
    ctx.stroke();
    
    ctx.fillStyle    = '#fff';
    ctx.font         = 'bold 14px Arial';
    ctx.textAlign    = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('⚠️ PASO PREVIO', centerX, centerY - 15);
    ctx.font = '12px Arial';
    ctx.fillText('Cortar márgenes antes de continuar', centerX, centerY + 10);
  }
}

// Calcular secciones del tablero según cortes realizados
function calcularSecciones(piezas, cortesRealizados) {
  const GAP = 15; // Separación visual entre secciones
  
  if (cortesRealizados.length === 0) {
    return [{
      x: 0,
      y: 0,
      ancho: tableroActual.ancho,
      alto:  tableroActual.alto || tableroActual.largo,
      piezas: piezas,
      activa:    true,
      cortada:   false,
      sobrante:  false,
      terminada: false
    }];
  }
  
  // Aplicar cortes de forma secuencial, manteniendo el historial de qué secciones están terminadas
  let secciones = [{
    minX: 0,
    minY: 0,
    maxX: tableroActual.ancho,
    maxY: tableroActual.alto || tableroActual.largo,
    piezas: piezas,
    terminada: false
  }];
  
  cortesRealizados.forEach((corte, corteIdx) => {
    // Saltar cortes de margen (no modifican la geometría, solo son instrucciones)
    if (corte.esMargen) {
      return;
    }
    
    const nuevasSecciones = [];
    
    // Solo procesar la primera sección no terminada (la que está activa)
    let corteAplicado = false;
    
    secciones.forEach((seccion) => {
      if (seccion.terminada || seccion.piezas.length <= 1) {
        nuevasSecciones.push({...seccion, terminada: true});
        return;
      }
      
      if (corteAplicado) {
        nuevasSecciones.push(seccion);
        return;
      }
      
      let corteDividio = false;
      
      if (corte.tipo === 'horizontal') {
        if (corte.y > seccion.minY && corte.y < seccion.maxY) {
          const piezasSup = seccion.piezas.filter(p => {
            const py = p.y || 0;
            const pAlto = (p.alto || p.largo) || 0;
            return (py + pAlto) <= corte.y;
          });
          const piezasInf = seccion.piezas.filter(p => {
            const py = p.y || 0;
            return py >= corte.y;
          });
          
          if (piezasSup.length > 0) {
            corteDividio = true;
            corteAplicado = true;
            nuevasSecciones.push({
              minX: seccion.minX, minY: seccion.minY,
              maxX: seccion.maxX, maxY: corte.y,
              piezas: piezasSup,
              terminada: piezasSup.length <= 1
            });
            nuevasSecciones.push({
              minX: seccion.minX, minY: corte.y,
              maxX: seccion.maxX, maxY: seccion.maxY,
              piezas: piezasInf,
              terminada: piezasInf.length <= 1
            });
          }
        }
      } else {
        if (corte.x > seccion.minX && corte.x < seccion.maxX) {
          const piezasIzq = seccion.piezas.filter(p => {
            const px = p.x || 0;
            const pAncho = p.ancho || 0;
            return (px + pAncho) <= corte.x;
          });
          const piezasDer = seccion.piezas.filter(p => {
            const px = p.x || 0;
            return px >= corte.x;
          });
          
          if (piezasIzq.length > 0) {
            corteDividio = true;
            corteAplicado = true;
            nuevasSecciones.push({
              minX: seccion.minX, minY: seccion.minY,
              maxX: corte.x,      maxY: seccion.maxY,
              piezas: piezasIzq,
              terminada: piezasIzq.length <= 1
            });
            nuevasSecciones.push({
              minX: corte.x,      minY: seccion.minY,
              maxX: seccion.maxX, maxY: seccion.maxY,
              piezas: piezasDer,
              terminada: piezasDer.length <= 1
            });
          }
        }
      }
      
      if (!corteDividio) {
        nuevasSecciones.push(seccion);
      }
    });
    
    secciones = nuevasSecciones;
  });
  
  // Convertir a formato de salida y marcar la primera sección no terminada como activa
  let activaMarcada = false;
  return secciones.map((sec) => {
    const esSobrante = sec.piezas.length === 0;
    const esTerminada = sec.terminada || sec.piezas.length <= 1;
    const esActiva = !activaMarcada && !esTerminada && !esSobrante;
    if (esActiva) activaMarcada = true;

    return {
      x: sec.minX,
      y: sec.minY,
      ancho: sec.maxX - sec.minX,
      alto:  sec.maxY - sec.minY,
      piezas: sec.piezas,
      activa:    esActiva && corteIndex < cortes.length,
      cortada:   esTerminada && !esSobrante,
      sobrante:  esSobrante,
      terminada: esTerminada
    };
  });
}

function dibujarCorteActual(corte, color, lineWidth, seccionActiva) {
  ctx.strokeStyle = color;
  ctx.lineWidth = lineWidth;
  ctx.setLineDash([5, 5]);
  
  // Base de render de la sección activa
  const baseX = seccionActiva ? seccionActiva.renderX : PADDING;
  const baseY = seccionActiva ? seccionActiva.renderY : PADDING;
  const secAncho = seccionActiva ? seccionActiva.ancho * SCALE : 0;
  const secAlto  = seccionActiva ? seccionActiva.alto  * SCALE : 0;
  // Origen lógico de la sección
  const logX = seccionActiva ? seccionActiva.x : 0;
  const logY = seccionActiva ? seccionActiva.y : 0;
  
  if (corte.tipo === 'horizontal') {
    // Línea horizontal dentro de los límites horizontales de la sección
    const x1 = baseX;
    const x2 = baseX + secAncho;
    const y  = baseY + (corte.y - logY) * SCALE;
    
    ctx.beginPath();
    ctx.moveTo(x1, y);
    ctx.lineTo(x2, y);
    ctx.stroke();
    
    ctx.setLineDash([]);
    ctx.fillStyle = color;
    dibujarFlecha(ctx, x1 + 10, y, -10, 0);
    dibujarFlecha(ctx, x2 - 10, y, 10, 0);
  } else {
    // Línea vertical dentro de los límites verticales de la sección
    const x  = baseX + (corte.x - logX) * SCALE;
    const y1 = baseY;
    const y2 = baseY + secAlto;
    
    ctx.beginPath();
    ctx.moveTo(x, y1);
    ctx.lineTo(x, y2);
    ctx.stroke();
    
    ctx.setLineDash([]);
    ctx.fillStyle = color;
    dibujarFlecha(ctx, x, y1 + 10, 0, -10);
    dibujarFlecha(ctx, x, y2 - 10, 0,  10);
  }
  
  ctx.setLineDash([]);
}

function dibujarFlecha(ctx, x, y, dx, dy) {
  const tam = 8;
  ctx.save();
  ctx.translate(x + dx, y + dy);
  
  if (dx !== 0) {
    const dir = dx > 0 ? 1 : -1;
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.lineTo(-dir * tam, -tam/2);
    ctx.lineTo(-dir * tam, tam/2);
    ctx.closePath();
    ctx.fill();
  } else {
    const dir = dy > 0 ? 1 : -1;
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.lineTo(-tam/2, -dir * tam);
    ctx.lineTo(tam/2, -dir * tam);
    ctx.closePath();
    ctx.fill();
  }
  
  ctx.restore();
}

// ===== NAVEGACIÓN =====
function siguienteCorte() {
  if (corteIndex < cortes.length) {
    corteIndex++;
    dibujarTablero();
    
    if (corteIndex >= cortes.length) {
      // Completado
      document.getElementById('btnSiguiente').disabled = true;
      mostrarModalCompletado();
    }
  }
}

function reiniciarTablero() {
  corteIndex = 0;
  document.getElementById('btnSiguiente').disabled = false;
  dibujarTablero();
}

function mostrarModalCompletado() {
  const modal = new bootstrap.Modal(document.getElementById('modalCompletado'));
  modal.show();
}

function seleccionarOtroTablero() {
  const modal = bootstrap.Modal.getInstance(document.getElementById('modalCompletado'));
  modal.hide();
  document.getElementById('tableroSelect').focus();
}
</script>
{% endblock %}
