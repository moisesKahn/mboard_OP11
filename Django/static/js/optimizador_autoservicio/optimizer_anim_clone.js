// Clon de optimizer_anim.js para flujo autoservicio independiente
// Mantiene misma API: OptimizerAnimClone.start(selector, mode)
(function(){
  const OptimizerAnimClone = {};
  function rand(min,max){ return Math.random()*(max-min)+min; }
  function lerp(a,b,t){ return a+(b-a)*t; }
  const PALETTE = ['#4c566a','#5e81ac','#8fbcbb','#81a1c1','#d08770','#ebcb8b','#a3be8c'];
  class BoardAnimation {
    constructor(canvas, mode){ this.canvas=canvas; this.ctx=canvas.getContext('2d'); this.mode=mode; this.running=true; this.lastTs=null; this.elapsed=0; this.phase=0; this.cells=[]; if(mode==='opt'){ this.setupOpt(); } else { this.setupPdf(); } requestAnimationFrame(this.loop.bind(this)); }
    setupOpt(){ const {width,height}=this.canvas; const margin=14; const pad=4; const areaW=width-margin*2; const areaH=height-margin*2; const baseSizes=[{w:areaW*0.30,h:areaH*0.32},{w:areaW*0.22,h:areaH*0.32},{w:areaW*0.26,h:areaH*0.22},{w:areaW*0.18,h:areaH*0.22},{w:areaW*0.20,h:areaH*0.30},{w:areaW*0.24,h:areaH*0.30},{w:areaW*0.15,h:areaH*0.30}]; baseSizes.forEach(s=>{s.w*=rand(0.93,1.06); s.h*=rand(0.92,1.05);}); let yCursor=margin; let colorIdx=0; const rows=[baseSizes.slice(0,4),baseSizes.slice(4)]; rows.forEach(row=>{ let xCursor=margin; const rowH=Math.max(...row.map(p=>p.h)); row.forEach(p=>{ this.cells.push({baseX:xCursor+p.w/2, baseY:yCursor+rowH/2, x:rand(0,width), y:rand(0,height), w:p.w, h:p.h, color:PALETTE[colorIdx%PALETTE.length], tEnter:rand(0,300)}); colorIdx++; xCursor+=p.w+pad; }); yCursor+=rowH+pad; }); this.shuffleTimer=0; }
    shuffle(){ const indices=[...this.cells.keys()]; for(let i=indices.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [indices[i],indices[j]]=[indices[j],indices[i]]; } const dest=indices.map(i=>({x:this.cells[i].baseX,y:this.cells[i].baseY})); this.cells.forEach((c,i)=>{ c.baseX=dest[i].x; c.baseY=dest[i].y; }); }
    setupPdf(){ const {width,height}=this.canvas; const count=26; for(let i=0;i<count;i++){ const w=rand(22,66); const h=rand(20,56); this.cells.push({x:rand(width*0.12,width*0.88), y:rand(height*0.22,height*0.78), w,h, tx:0, ty:0, color:'rgba(255,255,255,0.25)'}); } let cx=0, cy=0, rowH=0; const pad=3; const maxW=width*0.62; this.cells.forEach(p=>{ if(cx+p.w>maxW){ cx=0; cy+=rowH+pad; rowH=0; } p.tx=width*0.20+cx; p.ty=height*0.18+cy; cx+=p.w+pad; rowH=Math.max(rowH,p.h); }); this.totalPackedHeight=cy+rowH; }
    loop(ts){ if(!this.running) return; if(!this.lastTs) this.lastTs=ts; const dt=ts-this.lastTs; this.lastTs=ts; this.elapsed+=dt; if(this.mode==='opt'){ this.shuffleTimer+=dt; if(this.shuffleTimer>1500){ this.shuffle(); this.shuffleTimer=0; } } else { const phaseDur={0:1100,1:1100,2:650}[this.phase]||900; if(this.elapsed>phaseDur){ this.phase++; this.elapsed=0; if(this.phase>2) this.phase=3; } } this.draw(); requestAnimationFrame(this.loop.bind(this)); }
    draw(){ const ctx=this.ctx; const {width,height}=this.canvas; ctx.clearRect(0,0,width,height); if(this.mode==='opt'){ const pulse=(Math.sin(this.elapsed/520)+1)/2; ctx.strokeStyle=`rgba(255,255,255,${0.35+pulse*0.30})`; ctx.lineWidth=2; ctx.strokeRect(5,5,width-10,height-10); this.cells.forEach(c=>{ const tIn=Math.min(1,(this.elapsed-c.tEnter)/600); const eased=tIn<0?0:(tIn*tIn*(3-2*tIn)); c.x=lerp(c.x,c.baseX,0.10); c.y=lerp(c.y,c.baseY,0.10); const scale=eased*0.93+0.07; ctx.save(); ctx.translate(c.x,c.y); ctx.scale(scale,scale); ctx.fillStyle=c.color; ctx.globalAlpha=0.85+pulse*0.10; ctx.beginPath(); ctx.rect(-c.w/2,-c.h/2,c.w,c.h); ctx.fill(); ctx.strokeStyle='rgba(255,255,255,0.50)'; ctx.lineWidth=1.1; ctx.stroke(); ctx.restore(); }); } else { this.cells.forEach(p=>{ let cx,cy,cw,ch; if(this.phase===0){ cx=p.x; cy=p.y; cw=p.w; ch=p.h; } else if(this.phase===1){ cx=lerp(p.x,p.tx,this.elapsed/1000); cy=lerp(p.y,p.ty,this.elapsed/1000); cw=p.w; ch=p.h; } else if(this.phase===2){ const pageW=width*0.52; const pageH=this.totalPackedHeight+38; const baseX=width*0.5; const baseY=height*0.5; cx=lerp(p.tx,baseX,this.elapsed/620); cy=lerp(p.ty,baseY,this.elapsed/620); cw=lerp(p.w,pageW,this.elapsed/620); ch=lerp(p.h,pageH,this.elapsed/620); } else { cx=width*0.5; cy=height*0.5; cw=width*0.52; ch=this.totalPackedHeight+38; } ctx.save(); ctx.translate(cx,cy); ctx.fillStyle=p.color; ctx.globalAlpha=0.80; ctx.beginPath(); ctx.rect(-cw/2,-ch/2,cw,ch); ctx.fill(); ctx.restore(); }); if(this.phase>=3){ ctx.save(); ctx.translate(width*0.5,height*0.5); ctx.strokeStyle='rgba(255,255,255,0.85)'; ctx.lineWidth=3; ctx.strokeRect(-width*0.52/2,-(this.totalPackedHeight+38)/2,width*0.52,this.totalPackedHeight+38); ctx.fillStyle='rgba(255,255,255,0.90)'; ctx.font='bold 28px system-ui'; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText('PDF',0,0); ctx.restore(); } }
    }
    finish(){ this.running=false; }
  }
  OptimizerAnimClone.start=function(selector,mode){ const el=typeof selector==='string'?document.querySelector(selector):selector; if(!el) return {finish:()=>{}}; el.classList.add('oa-visible'); if(!el.querySelector('.oa-label')){ const lbl=document.createElement('div'); lbl.className='oa-label'; lbl.textContent=(mode==='opt'?'Optimizando…':'Generando PDF…'); el.appendChild(lbl);} else { el.querySelector('.oa-label').textContent=(mode==='opt'?'Optimizando…':'Generando PDF…'); } const canvas=el.querySelector('canvas'); if(!canvas){ return {finish:()=> el.classList.remove('oa-visible')}; } canvas.width=300; canvas.height=210; const anim=new BoardAnimation(canvas,mode); return {finish:()=>{anim.finish(); el.classList.remove('oa-visible');}}; };
  window.OptimizerAnimClone=OptimizerAnimClone;
})();